use crate::ast::{Module, Node, Stmt, Expr, Visitor};
use crate::token::{Token, TokenKind};
use crate::ty::{Type, TypeKind};
use crate::ast::{Modifier, Derived};
use std::fmt::Write;

/// The CppCodeGenerator traverses the AST and produces C++ source code.
pub struct CppCodeGenerator {
    output: String,
    indent_level: usize,
}

impl CppCodeGenerator {
    /// Creates a new C++ code generator.
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    /// Generate C++ code from a Module AST.
    pub fn generate(&mut self, module: &Module) -> String {
        // C++ header includes.
        self.writeln("#include <iostream>");
        self.writeln("#include <vector>");
        self.writeln("#include <string>");
        self.writeln("#include <sstream>");
        self.writeln("#include <cstdlib>");
        self.writeln("#include \"std.hpp\"");
        self.writeln("");
        module.accept(self);
        self.output.clone()
    }

    /// Returns a string of indentation based on the current indent level.
    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }

    /// Writes a line with the current indent.
    fn writeln(&mut self, line: &str) {
        let _ = writeln!(self.output, "{}{}", self.indent(), line);
    }

    /// A helper to temporarily capture output generated by a closure.
    fn capture_output<F: FnOnce(&mut Self)>(&mut self, f: F) -> String {
        let original = self.output.clone();
        self.output.clear();
        f(self);
        let captured = self.output.clone();
        self.output = original;
        captured
    }

    /// Translates a source language Type into a corresponding C++ type.
    fn translate_type(&self, ty: &Type) -> String {
        match &ty.kind {
            TypeKind::Int => "int".to_string(),
            TypeKind::Float => "float".to_string(),
            TypeKind::String => "String".to_string(),
            TypeKind::Void => "void".to_string(),
            TypeKind::User(name) => name.clone(), // assume user types become class names
            TypeKind::Array(inner, depth) => {
                let mut inner_type = self.translate_type(inner);
                for _ in 0..*depth {
                    inner_type = format!("std::vector<{}>", inner_type);
                }
                inner_type
            }
            _ => "int".to_string(), // fallback
        }
    }

    /// Check if a function is a built-in function and generate its C++ code.
    /// Returns true if the function is a built-in and was generated.
    fn builtin_function(&mut self, name: &Token, params: &Vec<Box<Stmt>>, return_type: &Type) -> bool {
        if name.lexeme == "print" {
            self.writeln("void print(std::string s) {");
            self.indent_level += 1;
            self.writeln("std::cout << s;");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "println" {
            self.writeln("void println(std::string s) {");
            self.indent_level += 1;
            self.writeln("std::cout << s << std::endl;");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "input" {
            self.writeln("std::string input() {");
            self.indent_level += 1;
            self.writeln("std::string line;");
            self.writeln("std::getline(std::cin, line);");
            self.writeln("return line;");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "toInt" {
            self.writeln("int toInt(std::string s) {");
            self.indent_level += 1;
            self.writeln("return std::stoi(s);");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "toFloat" {
            self.writeln("float toFloat(std::string s) {");
            self.indent_level += 1;
            self.writeln("return std::stof(s);");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "toString" {
            self.writeln("std::string toString(int s) {");
            self.indent_level += 1;
            self.writeln("return std::to_string(s);");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "len" {
            self.writeln("int len(std::string s) {");
            self.indent_level += 1;
            self.writeln("return s.size();");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        if name.lexeme == "charAt" {
            self.writeln("std::string charAt(std::string s, int i) {");
            self.indent_level += 1;
            self.writeln("return s[i];");
            self.indent_level -= 1;
            self.writeln("}");
            return true;
        }
        false
    }
}

/// Implement the Visitor trait to generate C++ code.
/// Each method converts the corresponding AST node into its C++ representation.
impl Visitor for CppCodeGenerator {
    // Module
    fn visit_module(&mut self, module: &Module) {
        for stmt in &module.statements {
            stmt.accept(self);
        }
    }

    // Statements
    fn visit_block(&mut self, stmt: &Stmt) {
        if let Stmt::Block { statements } = stmt {
            self.writeln("{");
            self.indent_level += 1;
            for s in statements {
                s.accept(self);
            }
            self.indent_level -= 1;
            self.writeln("}");
        }
    }

    fn visit_expression(&mut self, stmt: &Stmt) {
        if let Stmt::Expression { expression } = stmt {
            self.output.push_str(&self.indent());
            expression.accept(self);
            self.output.push_str(";");
            self.output.push('\n');
        }
    }

    fn visit_if(&mut self, stmt: &Stmt) {
        if let Stmt::If { condition, then_branch, else_branch } = stmt {
            self.output.push_str(&self.indent());
            self.output.push_str("if (");
            condition.accept(self);
            self.output.push_str(") ");
            match &**then_branch {
                Stmt::Block { .. } => then_branch.accept(self),
                _ => {
                    self.output.push('\n');
                    self.indent_level += 1;
                    then_branch.accept(self);
                    self.indent_level -= 1;
                }
            }
            if let Some(else_branch) = else_branch {
                self.output.push_str(&self.indent());
                self.output.push_str("else ");
                match &**else_branch {
                    Stmt::Block { .. } => else_branch.accept(self),
                    _ => {
                        self.output.push('\n');
                        self.indent_level += 1;
                        else_branch.accept(self);
                        self.indent_level -= 1;
                    }
                }
            }
        }
    }

    fn visit_while(&mut self, stmt: &Stmt) {
        if let Stmt::While { condition, body } = stmt {
            self.output.push_str(&self.indent());
            self.output.push_str("while (");
            condition.accept(self);
            self.output.push_str(") ");
            body.accept(self);
        }
    }

    fn visit_for(&mut self, stmt: &Stmt) {
        if let Stmt::For { initialiser, condition, increment, body } = stmt {
            self.output.push_str(&self.indent());
            self.output.push_str("for (");
            if let Some(init) = initialiser {
                let init_code = self.capture_output(|gen| { init.accept(gen); });
                self.output.push_str(&init_code);
            } else {
                self.output.push_str("; ");
            }
            if let Some(cond) = condition {
                let cond_code = self.capture_output(|gen| { cond.accept(gen); });
                self.output.push_str(&cond_code);
            }
            self.output.push_str("; ");
            if let Some(inc) = increment {
                let inc_code = self.capture_output(|gen| { inc.accept(gen); });
                self.output.push_str(&inc_code);
            }
            self.output.push_str(") ");
            body.accept(self);
        }
    }

    fn visit_return(&mut self, stmt: &Stmt) {
        if let Stmt::Return { token: _, value } = stmt {
            self.output.push_str(&self.indent());
            self.output.push_str("return");
            if let Some(expr) = value {
                self.output.push(' ');
                expr.accept(self);
            }
            self.output.push_str(";");
            self.output.push('\n');
        }
    }

    fn visit_break(&mut self, stmt: &Stmt) {
        if let Stmt::Break { token: _ } = stmt {
            self.writeln("break;");
        }
    }

    fn visit_continue(&mut self, stmt: &Stmt) {
        if let Stmt::Continue { token: _ } = stmt {
            self.writeln("continue;");
        }
    }

    fn visit_variable(&mut self, stmt: &Stmt) {
        if let Stmt::Variable { name, initialiser, type_, modifiers: _, derived: _ } = stmt {
            let cpp_type = self.translate_type(type_);
            self.output.push_str(&self.indent());
            self.output.push_str(&cpp_type);
            self.output.push(' ');
            self.output.push_str(&name.lexeme);
            if let Some(init) = initialiser {
                self.output.push_str(" = ");
                init.accept(self);
            }
            self.output.push_str(";");
            self.output.push('\n');
        }
    }

    fn visit_function(&mut self, stmt: &Stmt) {
        if let Stmt::Function { name, params, body, return_type, modifiers, generics: _ } = stmt {
            if modifiers.contains(&Modifier::Extern) {
                if self.builtin_function(name, params, return_type) {
                    return;
                }
            }
            
            let ret_type = self.translate_type(return_type);
            let mut param_str = String::new();
            for (i, param) in params.iter().enumerate() {
                if let Stmt::Variable { name: param_name, type_, .. } = &**param {
                    let cpp_type = self.translate_type(type_);
                    write!(&mut param_str, "{} {}", cpp_type, param_name.lexeme).unwrap();
                    if i < params.len() - 1 {
                        param_str.push_str(", ");
                    }
                }
            }
            self.writeln(&format!("{} {}({})", ret_type, name.lexeme, param_str));
            self.output.push_str(&self.indent());
            self.output.push_str("{\n");
            self.indent_level += 1;
            for s in body {
                s.accept(self);
            }
            self.indent_level -= 1;
            self.writeln("}");
        }
    }

    fn visit_import(&mut self, stmt: &Stmt) {
        if let Stmt::Import { path, alias: _ } = stmt {
            self.output.push_str(&self.indent());
            self.output.push_str("#include ");
            path.accept(self);
            self.output.push('\n');
        }
    }

    fn visit_class(&mut self, stmt: &Stmt) {
        if let Stmt::Class { name, generics: _, modifier: _, public_methods, private_methods, protected_methods, static_methods, public_fields, private_fields, protected_fields, static_fields } = stmt {
            // Generate a class definition.
            self.writeln(&format!("class {} {{", name.lexeme));
            self.indent_level += 1;
            self.writeln("public:");
            self.indent_level += 1;
            // Combine all field declarations.
            for field in public_fields.iter()
                .chain(private_fields.iter())
                .chain(protected_fields.iter())
                .chain(static_fields.iter())
            {
                if let Stmt::Variable { name: field_name, type_, .. } = &**field {
                    let cpp_type = self.translate_type(type_);
                    self.writeln(&format!("{} {};", cpp_type, field_name.lexeme));
                }
            }
            self.indent_level -= 1;
            self.writeln("};");
            // Generate methods as standalone functions.
            let mut all_methods = Vec::new();
            all_methods.extend(public_methods.iter());
            all_methods.extend(private_methods.iter());
            all_methods.extend(protected_methods.iter());
            all_methods.extend(static_methods.iter());
            for method in all_methods {
                if let Stmt::Function { name: method_name, params, body, return_type, .. } = &**method {
                    let ret_type = self.translate_type(return_type);
                    let mut param_str = String::new();
                    // For instance methods, include a reference to the object.
                    param_str.push_str(&format!("{}& self", name.lexeme));
                    if !params.is_empty() {
                        param_str.push_str(", ");
                    }
                    for (i, param) in params.iter().enumerate() {
                        if let Stmt::Variable { name: param_name, type_, .. } = &**param {
                            let cpp_type = self.translate_type(type_);
                            write!(&mut param_str, "{} {}", cpp_type, param_name.lexeme).unwrap();
                            if i < params.len() - 1 {
                                param_str.push_str(", ");
                            }
                        }
                    }
                    self.writeln(&format!("{} {}_{}({})", ret_type, name.lexeme, method_name.lexeme, param_str));
                    self.output.push_str(&self.indent());
                    self.output.push_str("{\n");
                    self.indent_level += 1;
                    for s in body {
                        s.accept(self);
                    }
                    self.indent_level -= 1;
                    self.writeln("}");
                }
            }
        }
    }

    // Expression visitors
    fn visit_binary(&mut self, expr: &Expr) {
        if let Expr::Binary { left, op, right } = expr {
            self.output.push('(');
            left.accept(self);
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            right.accept(self);
            self.output.push(')');
        }
    }

    fn visit_unary(&mut self, expr: &Expr) {
        if let Expr::Unary { op, right } = expr {
            self.output.push_str(&op.lexeme);
            right.accept(self);
        }
    }

    fn visit_literal(&mut self, expr: &Expr) {
        if let Expr::Literal { value } = expr {
            self.output.push_str(&value.lexeme);
        }
    }

    fn visit_grouping(&mut self, expr: &Expr) {
        if let Expr::Grouping { expression } = expr {
            self.output.push('(');
            expression.accept(self);
            self.output.push(')');
        }
    }

    fn visit_variable_expr(&mut self, expr: &Expr) {
        if let Expr::Variable { name } = expr {
            self.output.push_str(&name.lexeme);
        }
    }

    fn visit_assignment(&mut self, expr: &Expr) {
        if let Expr::Assignment { name, value, op } = expr {
            self.output.push_str(&name.lexeme);
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            value.accept(self);
        }
    }

    fn visit_call(&mut self, expr: &Expr) {
        if let Expr::Call { callee, paren: _, arguments } = expr {
            callee.accept(self);
            self.output.push('(');
            for (i, arg) in arguments.iter().enumerate() {
                arg.accept(self);
                if i < arguments.len() - 1 {
                    self.output.push_str(", ");
                }
            }
            self.output.push(')');
        }
    }

    fn visit_generic_call(&mut self, expr: &Expr) {
        if let Expr::GenericCall { callee, paren: _, arguments, generics: _ } = expr {
            // In C++ generics (templates) are handled differently; ignore generic arguments here.
            callee.accept(self);
            self.output.push('(');
            for (i, arg) in arguments.iter().enumerate() {
                arg.accept(self);
                if i < arguments.len() - 1 {
                    self.output.push_str(", ");
                }
            }
            self.output.push(')');
        }
    }

    fn visit_member_access(&mut self, expr: &Expr) {
        if let Expr::MemberAccess { object, name } = expr {
            object.accept(self);
            match *object.clone() {
                Expr::Reference { object: _ } => self.output.push_str("->"),
                Expr::MutReference { object: _ } => self.output.push_str("->"),
                _ => self.output.push_str("."),
            }
            self.output.push_str(&name.lexeme);
        }
    }

    fn visit_static_access(&mut self, expr: &Expr) {
        if let Expr::StaticAccess { object, name } = expr {
            object.accept(self);
            self.output.push_str("::");
            self.output.push_str(&name.lexeme);
        }
    }

    fn visit_index(&mut self, expr: &Expr) {
        if let Expr::Index { object, index, token: _ } = expr {
            object.accept(self);
            self.output.push('[');
            index.accept(self);
            self.output.push(']');
        }
    }

    fn visit_cast(&mut self, expr: &Expr) {
        if let Expr::Cast { object, type_ } = expr {
            self.output.push('(');
            self.output.push_str(&self.translate_type(type_));
            self.output.push_str(") ");
            object.accept(self);
        }
    }

    fn visit_class_init(&mut self, expr: &Expr) {
        if let Expr::ClassInit { name, arguments } = expr {
            // Map a class initialization to a call to its constructor.
            self.output.push_str(&name.lexeme);
            self.output.push_str("_init(");
            for (i, arg) in arguments.iter().enumerate() {
                arg.accept(self);
                if i < arguments.len() - 1 {
                    self.output.push_str(", ");
                }
            }
            self.output.push(')');
        }
    }

    fn visit_dereference(&mut self, expr: &Expr) {
        if let Expr::Dereference { object } = expr {
            self.output.push('*');
            object.accept(self);
        }
    }

    fn visit_reference(&mut self, expr: &Expr) {
        if let Expr::Reference { object } = expr {
            self.output.push('&');
            object.accept(self);
        }
    }

    fn visit_mut_reference(&mut self, expr: &Expr) {
        if let Expr::MutReference { object } = expr {
            self.output.push('&');
            object.accept(self);
        }
    }

    fn visit_closure(&mut self, expr: &Expr) {
        if let Expr::Closure { name, parameters, param_types, body, return_type } = expr {
            // Generate a unique function name for the closure.
            let func_name = format!("closure_{}", name.lexeme);
            let ret_type = self.translate_type(return_type);
            let mut params_str = String::new();
            for (i, param) in parameters.iter().enumerate() {
                let param_type = self.translate_type(&param_types[i]);
                write!(&mut params_str, "{} {}", param_type, param.lexeme).unwrap();
                if i < parameters.len() - 1 {
                    params_str.push_str(", ");
                }
            }
            self.writeln(&format!("static {} {}({}) {{", ret_type, func_name, params_str));
            self.indent_level += 1;
            body.accept(self);
            self.indent_level -= 1;
            self.writeln("}");
            // In the closure expression, return the function pointer.
            self.output.push_str(&func_name);
        }
    }

    fn visit_array(&mut self, expr: &Expr) {
        // For arrays, generate an initializer list for std::vector.
        if let Expr::Array { elements } = expr {
            self.output.push('{');
            for (i, element) in elements.iter().enumerate() {
                element.accept(self);
                if i < elements.len() - 1 {
                    self.output.push_str(", ");
                }
            }
            self.output.push('}');
        }
    }

    fn visit_tuple(&mut self, expr: &Expr) {
        if let Expr::Tuple { elements } = expr {
            // Represent a tuple as a comma-separated list enclosed in parentheses.
            self.output.push('(');
            for (i, element) in elements.iter().enumerate() {
                element.accept(self);
                if i < elements.len() - 1 {
                    self.output.push_str(", ");
                }
            }
            self.output.push(')');
        }
    }

    fn visit_member_assignment(&mut self, expr: &Expr) {
        if let Expr::MemberAssignment { object, name, value, op } = expr {
            object.accept(self);
            self.output.push_str("->");
            self.output.push_str(&name.lexeme);
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            value.accept(self);
        }
    }

    fn visit_static_assignment(&mut self, expr: &Expr) {
        if let Expr::StaticAssignment { object, name, value, op } = expr {
            object.accept(self);
            self.output.push_str("::");
            self.output.push_str(&name.lexeme);
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            value.accept(self);
        }
    }

    fn visit_index_assignment(&mut self, expr: &Expr) {
        if let Expr::IndexAssignment { object, index, value, op, token: _ } = expr {
            object.accept(self);
            self.output.push('[');
            index.accept(self);
            self.output.push(']');
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            value.accept(self);
        }
    }

    fn visit_ptr_assignment(&mut self, expr: &Expr) {
        // Handle pointer assignment similarly to a normal assignment but with dereference.
        if let Expr::PtrAssignment { object, value, op } = expr {
            self.output.push('*');
            object.accept(self);
            self.output.push(' ');
            self.output.push_str(&op.lexeme);
            self.output.push(' ');
            value.accept(self);
        }
    }

    fn visit_extension(&mut self, stmt: &Stmt) {
        if let Stmt::Extension { target, methods } = stmt {
            let target_name = target.name.lexeme.clone();
            for method in methods {
                if let Stmt::Function { name, params, return_type, body, .. } = &**method {
                    let ret_type = self.translate_type(return_type);
                    let mut param_str = String::new();
                    // For extension methods, add the extended type as the first parameter.
                    write!(&mut param_str, "{}& self", self.translate_type(target)).unwrap();
                    if !params.is_empty() {
                        param_str.push_str(", ");
                    }
                    for (i, param) in params.iter().enumerate() {
                        if let Stmt::Variable { name: param_name, type_, .. } = &**param {
                            let t = self.translate_type(type_);
                            write!(&mut param_str, "{} {}", t, param_name.lexeme).unwrap();
                            if i < params.len() - 1 {
                                param_str.push_str(", ");
                            }
                        }
                    }
                    // Generate the function prototype (and body, if desired).
                    self.writeln(&format!("{} {}_extension_{}({})", ret_type, target_name, name.lexeme, param_str));
                    // Optionally, generate a stub body:
                    self.writeln("{");
                    self.indent_level += 1;
                    for s in body {
                        s.accept(self);
                    }
                    self.indent_level -= 1;
                    self.writeln("}");
                }
            }
        }
    }
}
